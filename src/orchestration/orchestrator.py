"""Orchestrator for managing multi-agent collaboration."""

import asyncio
from typing import List, Optional, Dict, Any
from datetime import datetime

from ..agents.base_agent import BaseAgent
from ..agents.squad_leader import SquadLeaderAgent
from ..channel.shared_channel import SharedChannel
from ..channel.message import Message, MessageType


class Orchestrator:
    """Manages agent turns, message flow, and collaboration coordination.

    The orchestrator:
    - Maintains the shared channel
    - Manages the agent roster
    - Determines which agents should respond
    - Enforces turn-taking and communication rules
    - Handles user messages
    """

    def __init__(
        self,
        channel: Optional[SharedChannel] = None,
        max_agents: int = 6,
        context_window: int = 20
    ):
        """Initialize the orchestrator.

        Args:
            channel: Shared channel for communication (creates new if not provided)
            max_agents: Maximum number of agents (excluding user)
            context_window: Number of messages for agent context
        """
        self.channel = channel or SharedChannel()
        self.agents: Dict[str, BaseAgent] = {}
        self.squad_leader: Optional[SquadLeaderAgent] = None
        self.max_agents = max_agents
        self.context_window = context_window
        self.is_running = False

    def add_agent(self, agent: BaseAgent) -> bool:
        """Add an agent to the orchestrator.

        Args:
            agent: Agent to add

        Returns:
            True if agent was added, False if roster is full
        """
        if len(self.agents) >= self.max_agents:
            return False

        self.agents[agent.agent_id] = agent

        # Track squad leader separately
        if isinstance(agent, SquadLeaderAgent):
            self.squad_leader = agent

        # Announce agent joining
        self.channel.add_message(
            sender_id="system",
            content=f"{agent.callsign} has joined the channel.",
            message_type=MessageType.SYSTEM
        )

        return True

    def remove_agent(self, agent_id: str) -> bool:
        """Remove an agent from the orchestrator.

        Args:
            agent_id: ID of agent to remove

        Returns:
            True if agent was removed
        """
        if agent_id not in self.agents:
            return False

        agent = self.agents[agent_id]
        del self.agents[agent_id]

        # Clear squad leader if removed
        if self.squad_leader and self.squad_leader.agent_id == agent_id:
            self.squad_leader = None

        # Announce agent leaving
        self.channel.add_message(
            sender_id="system",
            content=f"{agent.callsign} has left the channel.",
            message_type=MessageType.SYSTEM
        )

        return True

    def get_agent(self, agent_id: str) -> Optional[BaseAgent]:
        """Get an agent by ID.

        Args:
            agent_id: Agent ID

        Returns:
            Agent if found, None otherwise
        """
        return self.agents.get(agent_id)

    def send_user_message(self, content: str, user_id: str = "user") -> Message:
        """Send a message from the user.

        Args:
            content: Message content
            user_id: User identifier

        Returns:
            The sent message
        """
        return self.channel.add_message(
            sender_id=user_id,
            content=content,
            message_type=MessageType.USER
        )

    async def process_responses(
        self,
        max_responses: int = 3,
        timeout_seconds: float = 30.0
    ) -> List[Message]:
        """Process agent responses to recent messages.

        Args:
            max_responses: Maximum number of agents to respond
            timeout_seconds: Timeout for response generation

        Returns:
            List of messages generated by agents
        """
        responses = []
        responding_agents = []

        # Determine which agents should respond
        for agent in self.agents.values():
            if len(responding_agents) >= max_responses:
                break

            if agent.should_respond(self.channel, self.context_window):
                responding_agents.append(agent)

        # If no agents want to respond and we have a squad leader, they respond
        if not responding_agents and self.squad_leader:
            responding_agents.append(self.squad_leader)

        # Generate responses (now async)
        for agent in responding_agents:
            try:
                message = await agent.respond(self.channel, self.context_window)
                if message:
                    responses.append(message)
            except Exception as e:
                print(f"Error processing response from {agent.callsign}: {e}")

        return responses

    async def run_turn(
        self,
        user_message: Optional[str] = None,
        max_agent_responses: int = 3
    ) -> Dict[str, Any]:
        """Run a single turn of the collaboration.

        Args:
            user_message: Optional user message to start the turn
            max_agent_responses: Maximum number of agent responses

        Returns:
            Dict with turn results
        """
        turn_data = {
            "timestamp": datetime.now(),
            "user_message": None,
            "agent_responses": []
        }

        # Add user message if provided
        if user_message:
            msg = self.send_user_message(user_message)
            turn_data["user_message"] = msg

        # Process agent responses (now async)
        responses = await self.process_responses(max_responses=max_agent_responses)
        turn_data["agent_responses"] = responses

        return turn_data

    def get_active_agents(self) -> List[BaseAgent]:
        """Get list of all active agents.

        Returns:
            List of active agents
        """
        return list(self.agents.values())

    def get_agent_count(self) -> int:
        """Get number of active agents.

        Returns:
            Agent count
        """
        return len(self.agents)

    def clear_channel(self):
        """Clear all messages from the channel."""
        self.channel.clear()

    def get_channel_history(self, count: int = 10) -> str:
        """Get formatted channel history.

        Args:
            count: Number of recent messages

        Returns:
            Formatted history string
        """
        return self.channel.format_history(count)

    def start(self):
        """Mark orchestrator as running."""
        self.is_running = True
        self.channel.add_message(
            sender_id="system",
            content="Collaboration session started.",
            message_type=MessageType.SYSTEM
        )

    def stop(self):
        """Mark orchestrator as stopped."""
        self.is_running = False
        self.channel.add_message(
            sender_id="system",
            content="Collaboration session ended.",
            message_type=MessageType.SYSTEM
        )

    def get_status(self) -> Dict[str, Any]:
        """Get orchestrator status.

        Returns:
            Status information dict
        """
        return {
            "is_running": self.is_running,
            "agent_count": len(self.agents),
            "has_squad_leader": self.squad_leader is not None,
            "message_count": self.channel.get_message_count(),
            "agents": [
                {
                    "id": agent.agent_id,
                    "callsign": agent.callsign,
                    "type": agent.get_agent_type()
                }
                for agent in self.agents.values()
            ]
        }
